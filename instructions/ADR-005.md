# ADR-005: Implementation of Phishing-Resistant MFA via WebAuthn

## Status

**Proposed**
**Date:** 2025-12-26  
**Decider(s):** Engineering Leadership, Security Team

---

## Context

Our current authentication flow relies on legacy Multi-Factor Authentication
(MFA) methods, specifically SMS-based One-Time Passwords (OTP) and Push
Notifications. These methods are increasingly vulnerable to sophisticated
attacks:

* **SIM Swapping:** Intercepting SMS codes by hijacking the user's mobile
identity.
* **MFA Fatigue (Push Spamming):** Bombarding users with push requests until
they accidentally approve an unauthorized login.
* **Adversary-in-the-Middle (AiTM):** Phishing kits (e.g., Evilginx) that
proxy traffic to steal both credentials and session cookies in real-time.

To comply with **NIST SP 800-63B** standards and ensure modern security, we
require a "phishing-resistant" factor that cryptographically binds the
authentication process to our specific domain.

---

## Decision

We will implement **WebAuthn (FIDO2)** as the primary MFA mechanism. This move
shifts our security model from "shared secrets" to public-key cryptography.

### Key Implementation Requirements

1. **Authenticator Support:** Support both **Platform Authenticators**
    (TouchID, FaceID, Windows Hello) and **Roaming Authenticators** (Yubikeys,
    Google Titan keys).
2. **Domain Binding:** The implementation must strictly enforce origin checks
    to prevent credential relay.
3. **Registration Policy:** Users will be prompted to register at least two
    keys (e.g., one laptop biometric and one backup hardware key) to minimize
    lockout risks.
4. **Phased Rollout:** * **Phase 1:** Mandatory for DevOps, Admin, and
    Executive accounts.
    * **Phase 2:** Optional for general staff.
    * **Phase 3:** Deprecation of SMS/Push for all internal accounts.

---

## Technical Architecture

WebAuthn utilizes a challenge-response protocol between the **Relying Party
(our server)**, the **Client (the browser)**, and the **Authenticator (the
hardware)**.

* **Registration:** The server generates a unique challenge and user ID. The
  authenticator creates a new scoped credential pair and returns the public
  key.
* **Authentication:** The server sends a challenge. The browser ensures the
  domain matches the stored credential. The authenticator signs the challenge
  using the private key, which never leaves the hardware.

### High-Level Flow

1. User enters username/password.
2. Server verifies primary credentials and issues a WebAuthn `assertion`.
3. Browser invokes `navigator.credentials.get()`.
4. User interacts with biometric sensor or hardware key.
5. Server verifies the digital signature against the stored public key.

---

## Consequences

### Positive

* **Immunity to Phishing:** Credentials cannot be used on a fake domain, even
  if the user is tricked into interacting with it.
* **Improved User Experience:** Replaces manual code entry with a
  "single touch" or biometric scan.
* **Security Posture:** Meets the highest assurance levels required for modern
  enterprise compliance.

### Negative / Challenges

* **Hardware Procurement:** Initial cost for physical security keys for
  employees without compatible biometrics.
* **Account Recovery:** Requires a highly secure "Identity Proofing" flow if a
  user loses all registered keys.
* **Legacy Support:** Some older internal tools or legacy browsers may not
  support the WebAuthn API.

---

## References

* [FIDO Alliance - WebAuthn Specifications](https://fidoalliance.org/fido2/)
* [NIST SP 800-63B - Digital Identity Guidelines](https://pages.nist.gov/800-63-3/sp800-63b.html)
* [W3C Web Authentication API](https://www.w3.org/TR/webauthn-2/)
